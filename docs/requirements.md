# NovelDrive 要求仕様書

## 1. プロジェクトの背景と意図

### 1.1 解決したい課題

#### 創作における根本的な問題
1. **LLMのコンテキスト問題**
   - 現状のLLMは、プロンプトに含めた内容に過度にバイアスがかかる
   - 「うっすらと覚えている」人間的な記憶の再現ができない
   - 予期せぬ創発や意外な組み合わせが生まれにくい

2. **情報管理の非効率性**
   - 作家は日々大量の情報（ニュース、SNS、日常の気づき）に触れるが、創作に活かせていない
   - 取材メモや資料が死蔵されがち
   - アイデアの関連性を後から発見することが困難

3. **創作プロセスの孤独**
   - 一人で考えていると行き詰まりやすい
   - 客観的な視点が得られない
   - プロットの矛盾や設定の破綻に気づきにくい

### 1.2 製品コンセプト

#### NovelDriveが目指すもの
「**人間の創造的な記憶と発想のプロセスを模倣し、AIとの対話を通じて小説創作を支援するプラットフォーム**」

#### 核となる思想
1. **セレンディピティ（偶然の発見）の重視**
   - 完全にランダムでも、完全に関連性があるものでもない「程よい距離」の発見
   - 時間経過による記憶の「発酵」を再現

2. **二層構造による創造性の最大化**
   - 第1層：知識の蓄積と熟成（インプット）
   - 第2層：創作への昇華（アウトプット）
   - 層間の緩やかな結合による予期せぬ化学反応

3. **マルチエージェントによる多角的視点**
   - 作家AIの「程よく無視する」性格による創造性維持
   - 編集AI、校閲AI、副編集長AIによる品質保証
   - 人間はいつでも介入可能な「編集長」として君臨

### 1.3 製品概要
二層構造の創造的執筆プラットフォーム。セレンディピティ付き知識管理システムとマルチエージェント小説創作エンジンを統合し、人間の創造的記憶と発想プロセスを模倣する。

### 1.4 開発形態
- 個人開発のプロトタイプ
- デスクトップアプリケーション（Electron）
- ローカルファースト設計

## 2. 技術要件

### 2.1 必須技術スタック
- **プログラミング言語**: TypeScript（フロントエンド/バックエンド統一）
- **デスクトップフレームワーク**: Electron（最新安定版）
- **データベース**: SQLite3（better-sqlite3使用）
- **日本語処理**: TinySegmenter
- **ベクトル検索**: カスタム実装（in-memory）
- **全文検索**: SQLite3 FTS + 日本語トークナイザー
- **AI API**: OpenAI API（GPT-4、DALL-E）

### 2.2 開発環境要件
- **Node.js**: Electronが対応する最新バージョン
- **パッケージマネージャー**: npm
- **ビルドツール**: Vite（レンダラープロセス）、TypeScript Compiler（メインプロセス）
- **テストフレームワーク**: Jest、Playwright

### 2.3 技術的制約
- **埋め込み生成**: OpenAI APIは使用禁止。ローカルモデル（@xenova/transformers）を使用
- **Node.jsバージョン**: Electronとの互換性を最優先
- **ネイティブモジュール**: electron-rebuildでの再ビルドが必要

## 3. 機能要件

### 3.1 最小実装要件（MVP）
1. **Electronアプリケーションの起動**
   - メインプロセスとレンダラープロセスの正常動作
   - IPCによる双方向通信
   
2. **データベース接続と永続化**
   - SQLite3データベースへの接続
   - 基本的なCRUD操作
   - データの永続化確認（カウンタ機能でのテスト）

### 3.2 コア機能要件

#### 3.2.1 第1層：創造的知識管理システム

##### なんでもボックス（万能インプットシステム）

**なぜ必要か**：
作家は日常的に大量の情報に触れるが、その場では創作との関連性に気づかないことが多い。後から「あの記事のあの部分が使える」と思い出そうとしても、既に忘れてしまっている。この機能により、とりあえず気になったものは全て放り込んでおき、AIが自動的に創作の種を見つけ出す。

**機能詳細**：
- テキスト入力の受付と保存
- URLからの自動コンテンツ取得
- 画像のOCR処理
- AIによるインスピレーション抽出（5つの創作アイデアを自動生成）
- ノードの自動生成とベクトル埋め込み
- メタデータの付与（取得日時、ソース情報、感情タグなど）

**期待される効果**：
- 情報収集の心理的ハードルが下がる（「後で使えるかも」で気軽に保存）
- 意外な組み合わせの発見（ニュース記事から恋愛小説のアイデアが生まれるなど）
- 取材や日常観察の成果を無駄にしない

##### ノード管理システム

**なぜ必要か**：
従来のフォルダ管理では、情報は階層的に分類されるため、横断的な発見が困難。例えば「雨」に関する情報が、天気フォルダ、心情描写フォルダ、シーン設定フォルダに分散してしまう。ノードベースにすることで、多次元的な関連付けが可能になる。

**機能詳細**：
- 複数種類のノード（テキスト、画像、キャラクター、世界観、音楽、プロットなど）
- ノード間の自動リンク生成（内容の類似性、時系列、明示的な参照）
- ベクトル埋め込みの生成と保存（意味的な近さを計算可能に）
- タグとメタデータによる多角的な分類

**期待される効果**：
- 情報の再利用性向上
- 予期せぬ関連性の発見
- キャラクターや世界観の一貫性維持

##### セレンディピティ検索

**なぜ必要か**：
通常の検索では「探しているものしか見つからない」。創作において重要なのは「探していなかったけど、実は必要だったもの」を見つけること。人間の記憶の曖昧さや、ふとした瞬間の連想を再現する。

**機能詳細**：
- ベクトル類似検索（意味的に近いものを探す）
- ノイズ注入による意外な発見（検索ベクトルに意図的なブレを加える）
- 時間減衰（古い記憶ほど曖昧になる人間の記憶を模倣）
- ハイブリッド検索（キーワード検索と意味検索の組み合わせ）

**期待される効果**：
- 「そういえばこんなアイデアもあった」という再発見
- 異なる文脈の要素を組み合わせた新しいアイデア
- 創作の行き詰まりを打破

##### ナレッジグラフ

**なぜ必要か**：
頭の中にある概念のネットワークを外在化し、視覚的に把握することで、新たな関連性に気づく。また、作品世界の全体像を俯瞰することで、設定の矛盾や未開拓の領域を発見できる。

**機能詳細**：
- ノードの3D視覚化（関連性の強さを距離で表現）
- インタラクティブな操作（ドラッグで移動、クリックで詳細表示）
- リアルタイムでの更新（新しいノードが追加されると自動的に配置）
- フィルタリング機能（時期、タイプ、タグで絞り込み）

**期待される効果**：
- 知識の全体像の把握
- 隠れた関連性の発見
- 創作世界の一貫性確保

#### 3.2.2 第2層：小説創作エンジン

##### マルチエージェントシステム

**なぜ必要か**：
一人で創作していると、どうしても視野が狭くなり、独りよがりな作品になりがち。編集者との議論によって作品が磨かれるプロセスを、AIで再現する。ただし、各AIには明確な性格付けをすることで、建設的な議論を生み出す。

**機能詳細**：
- **作家AI**：創造性重視、「もしも〜だったら」の発想、編集の意見を「程よく無視」
- **編集AI**：読者視点、構成とペース配分、商業的成功の観点
- **校閲AI**：設定の矛盾検出、時系列の整合性、事実確認
- **副編集長AI**：全体を俯瞰、作品の方向性提案、品質評価
- エージェント間の自律的な対話
- 人間（編集長）による任意のタイミングでの介入

**期待される効果**：
- 多角的な視点による作品の深化
- 創作の行き詰まり解消
- 矛盾や破綻の早期発見
- 一人では思いつかない展開の発見

##### プロット管理

**なぜ必要か**：
プロットは創作の設計図だが、一度決めたら変更できないものではない。むしろ、様々な可能性を試行錯誤することで、最良の物語が生まれる。バージョン管理により、大胆な実験も安心して行える。

**機能詳細**：
- プロットのバージョニング（A→A'→A''）
- 分岐とマージ（異なる展開を並行して検討）
- プロット構造のテンプレート（三幕構成、起承転結、ヒーローズジャーニー等）
- 各バージョンでのAI議論履歴の保持
- プロット間の差分表示

**期待される効果**：
- 安心して大胆な変更を試せる
- 複数の可能性を並行検討
- 最良の要素を組み合わせた決定版の作成

##### 執筆支援

**なぜ必要か**：
長編小説では、前に書いた内容を忘れたり、設定に矛盾が生じたりしやすい。また、執筆中に行き詰まることも多い。AIがリアルタイムでサポートすることで、流れを止めずに執筆を続けられる。

**機能詳細**：
- 章単位での執筆管理
- リアルタイムでのAI提案（次の展開、表現の改善、伏線の活用）
- 矛盾検出と整合性チェック（キャラの性格、時系列、設定との齟齬）
- セレンディピティ検索による関連情報の提示
- 執筆統計（文字数、ペース、使用語彙など）

**期待される効果**：
- 執筆速度の向上
- 一貫性のある作品
- 伏線の適切な回収
- モチベーションの維持

### 3.3 追加機能要件

#### AI画像生成統合

**なぜ必要か**：
文章だけでは伝わりにくいビジュアルイメージを具現化することで、より鮮明な作品世界を構築できる。また、表紙やイラストの方向性を検討する際の参考にもなる。

**機能詳細**：
- DALL-E APIとの連携
- キャラクター設定からの自動画像生成
- シーン描写からの場面イラスト生成
- プロンプトテンプレートとカスタマイズ
- 生成履歴とお気に入り管理

**期待される効果**：
- ビジュアルイメージの共有
- キャラクターデザインの具体化
- 読者への訴求力向上

#### 分析・可視化

**なぜ必要か**：
作者は物語の全てを知っているため、読者がどう感じるかを客観的に判断しにくい。データとして可視化することで、ペース配分や感情曲線、伏線の効果を客観的に評価できる。

**機能詳細**：
- **感情グラフ**：章ごとの感情の起伏を可視化
- **伏線トラッカー**：伏線の配置と回収をタイムラインで管理
- **読者視点シミュレータ**：各時点で読者が知っている情報のみを表示
- **ペース分析**：アクションと静寂のバランス

**期待される効果**：
- 客観的な作品評価
- 構成の最適化
- 読者体験の向上

#### エクスポート機能

**なぜ必要か**：
作品は最終的に読者に届けられるもの。様々なプラットフォームや形式に対応することで、より多くの読者にリーチできる。

**機能詳細**：
- 縦書きPDF出力（日本の小説の標準形式）
- EPUB生成（電子書籍リーダー対応）
- Web小説形式への変換（なろう、カクヨム等への投稿用）
- ルビ、傍点などの日本語組版対応

**期待される効果**：
- 多様な公開手段の確保
- プロ仕様の原稿作成
- 読者の好みに応じた提供

## 4. アーキテクチャ要件

### 4.1 システムアーキテクチャ
```
┌─────────────────────────────────────────────┐
│          レンダラープロセス（React）           │
│  - UI/UXコンポーネント                       │
│  - 状態管理                                  │
│  - リアルタイム更新                          │
└─────────────────────────────────────────────┘
                      ↕ IPC
┌─────────────────────────────────────────────┐
│           メインプロセス（Node.js）           │
│  ┌─────────────────┐  ┌─────────────────┐ │
│  │   サービス層     │  │  リポジトリ層    │ │
│  │ - AI統合        │  │ - データアクセス  │ │
│  │ - ビジネスロジック│  │ - SQLクエリ     │ │
│  └─────────────────┘  └─────────────────┘ │
│              ↓                ↓             │
│  ┌─────────────────────────────────────┐   │
│  │        データベース層（SQLite3）      │   │
│  │ - ノードデータ                      │   │
│  │ - ベクトル埋め込み                  │   │
│  │ - プロジェクト設定                  │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
```

### 4.2 データベース設計
1. **メインテーブル**
   - nodes: ノード情報
   - embeddings: ベクトル埋め込み
   - links: ノード間リンク
   - projects: プロジェクト情報
   - agents: AIエージェント設定
   - plots: プロットデータ
   - chapters: 章データ

2. **インデックス戦略**
   - 全文検索用FTSインデックス
   - ベクトル検索用の最適化
   - 時系列データのインデックス

### 4.3 モジュール構成
```
src/
├── main/           # メインプロセス
│   ├── core/       # コア機能
│   ├── services/   # ビジネスロジック
│   ├── repositories/ # データアクセス
│   └── ipc/        # IPCハンドラー
├── renderer/       # レンダラープロセス
│   ├── components/ # UIコンポーネント
│   ├── pages/      # ページコンポーネント
│   ├── hooks/      # カスタムフック
│   └── utils/      # ユーティリティ
└── shared/         # 共有型定義・定数
```

## 5. 非機能要件

### 5.1 パフォーマンス要件
- アプリケーション起動時間: 5秒以内
- 検索レスポンス: 1秒以内（1万ノードまで）
- AI応答時間: OpenAI APIのレスポンス時間に依存
- メモリ使用量: 2GB以内（通常使用時）

### 5.2 ユーザビリティ要件
- 日本語UIの完全サポート
- ショートカットキーの提供
- ダークモード対応
- レスポンシブデザイン（ウィンドウサイズ変更対応）

### 5.3 信頼性要件
- データの自動保存（30秒ごと）
- クラッシュ時のデータ復旧
- エラーハンドリングとログ記録

### 5.4 セキュリティ要件
- APIキーの安全な保存（暗号化）
- ローカルデータの保護
- 外部通信はOpenAI APIのみ

## 6. 開発・運用要件

### 6.1 ビルド要件
- Windows向けビルドスクリプト（PowerShell）
- macOS/Linux向けビルドスクリプト（Bash）
- ネイティブモジュールの自動再ビルド

### 6.2 テスト要件
- 単体テスト（Jest）: カバレッジ80%以上
- 統合テスト: 主要フローのカバー
- E2Eテスト（Playwright）: クリティカルパスのテスト

### 6.3 デプロイ要件
- Electron Builderによるパッケージング
- 自動アップデート機能（将来実装）
- インストーラーの生成

## 7. 移行要件

### 7.1 DuckDBからSQLite3への移行
- すべてのDuckDB依存コードの削除
- SQLite3互換のクエリへの書き換え
- ベクトル検索機能の再実装
- データマイグレーションスクリプトの作成

### 7.2 既存データの移行
- DuckDB形式のデータエクスポート
- SQLite3形式へのインポート
- データ整合性の検証

## 8. 制約事項

### 8.1 技術的制約
- Electronのバージョンに依存したNode.jsバージョンの制限
- ネイティブモジュールのビルド問題への対応
- Windows/macOS/Linuxでの動作互換性

### 8.2 リソース制約
- 個人開発のため、実装は段階的に行う
- 外部ライブラリは最小限に抑える
- 保守性を重視したシンプルな設計

## 9. 今後の拡張計画

### 9.1 短期計画（3ヶ月以内）
- 基本的なノード管理機能の実装
- シンプルなAI統合
- 基本的な執筆支援機能

### 9.2 中期計画（6ヶ月以内）
- マルチエージェントシステムの完全実装
- 高度な検索機能
- プロット管理機能

### 9.3 長期計画（1年以内）
- 24時間自律稼働モード
- 共同執筆機能
- モバイルアプリ版

## 10. 特徴的な機能の意図

### 10.1 24時間自律稼働モード

**なぜ必要か**：
人間の創造性には波がある。深夜にアイデアが湧くこともあれば、仕事中にふと思いつくこともある。AIを24時間稼働させることで、人間が創作できない時間も活用し、次に開いた時に「AIがこんなものを考えておきました」という驚きを提供する。

**運用方法**：
- 品質スコアによるフィルタリング（低品質なものは自動破棄）
- トークン使用量の上限設定（コスト管理）
- 人間の最終承認が必要（勝手に完成はさせない）

### 10.2 作家AIの「程よく無視する」性格

**なぜ必要か**：
編集の意見を全て聞き入れると、無難だが面白みのない作品になる。かといって、全く聞かないと独りよがりになる。人間の作家のように「なるほど、でも自分はこう思う」という適度な頑固さが、創造性を保つ鍵となる。

**実装方法**：
- 編集意見の採用率を確率的に制御
- 作品のジャンルや雰囲気に応じて調整
- 重要な指摘（矛盾など）は必ず対応

### 10.3 セレンディピティ検索のノイズ注入

**なぜ必要か**：
完全な検索では「予想通りの結果」しか得られない。創作における「ひらめき」は、一見関係ないものを結びつけることから生まれる。ノイズを加えることで、人間の連想のような「ゆらぎ」を再現する。

**技術詳細**：
- ガウシアンノイズ：全体的な曖昧さ
- 次元選択的摂動：特定の属性だけをぼかす
- 時間減衰：古い記憶ほどノイズを大きく

## 11. 重要な実装上の課題と注意点

### 11.1 【最重要】Electronビルド環境の構築

**なぜ最初に取り組むべきか**：
Electronのビルド環境は想像以上に複雑で、特にネイティブモジュール（SQLite3など）を含む場合、何日も苦戦することがある。プロジェクトの序盤でこの問題を解決しておかないと、後で大きな手戻りが発生する。

**具体的な課題**：
1. **NODE_MODULE_VERSIONの不一致**
   - Node.jsとElectronで使用するV8エンジンのバージョンが異なる
   - 例：Node.js 22はMODULE_VERSION 136、Electron 37はMODULE_VERSION 115
   - この不一致により「The module was compiled against a different Node.js version」エラーが頻発

2. **ネイティブモジュールの再ビルド**
   - better-sqlite3などのネイティブモジュールは、Electron用に再ビルドが必要
   - electron-rebuildを使用しても、設定次第では正しく動作しない
   - Windows、macOS、Linuxで異なるビルド問題が発生

3. **文字コード問題（Windows）**
   - PowerShellスクリプトでUTF-8 with BOMを使うと日本語が化ける
   - `-Encoding UTF8`の指定が必要

**推奨される実装順序**：
1. **最小限のElectronアプリを作成**
   ```json
   // package.json
   {
     "main": "dist/main/index.js",
     "scripts": {
       "start": "electron .",
       "rebuild": "electron-rebuild -f -w better-sqlite3"
     }
   }
   ```

2. **ビルド環境の検証**
   - まずはHello Worldレベルで動作確認
   - SQLite3を追加して動作確認
   - カウンタアプリなど簡単な永続化で検証

3. **ビルドスクリプトの整備**
   ```powershell
   # fix-modules.ps1
   Write-Host "Fixing native modules for Electron..." -ForegroundColor Green
   npm run rebuild
   ```

**成功の基準**：
- `npm start`でElectronアプリが起動する
- SQLite3でのデータ永続化が動作する
- Windows/macOS/Linuxの少なくとも1つで動作確認

### 11.2 避けるべき技術選定

**DuckDBの教訓**：
- Electronとの互換性が不明確なライブラリは避ける
- ネイティブモジュールのビルドが複雑なものは慎重に検討
- WASMバージョンも、Electronのセキュリティポリシーで問題になることがある

**推奨技術**：
- **データベース**: SQLite3（better-sqlite3） - Electronでの実績多数
- **検索**: 自前実装 or 軽量なJSライブラリ
- **ベクトル演算**: Pure JavaScriptで実装

### 11.3 開発環境のセットアップ手順

**必須の準備**：
1. **Node.jsバージョン管理**
   - nvmやnvm-windowsを使用
   - Electronが対応するNode.jsバージョンを使用

2. **ビルドツールのインストール**
   - Windows: Visual Studio Build Tools
   - macOS: Xcode Command Line Tools
   - Linux: build-essential

3. **WSL環境での開発時の追加設定**
   ```bash
   # WSL2でGUIアプリ実行用ライブラリ
   sudo apt install libgconf-2-4 libatk1.0-0 libatk-bridge2.0-0 \
                    libgdk-pixbuf2.0-0 libgtk-3-0 libgbm-dev \
                    libnss3-dev libxss-dev
   ```

4. **推奨開発フロー（WSL環境）**
   - **開発・コーディング**: WSL2内で実施
   - **Linux版テスト**: WSL2内で実行（WSLg利用）
   - **Windows版ビルド**: Windows側（PowerShell）で実行
   - **理由**: ネイティブモジュールのクロスコンパイル問題を回避

5. **初期プロジェクト構成**
   ```
   noveldrive/
   ├── src/
   │   ├── main/       # メインプロセス
   │   └── renderer/   # レンダラープロセス
   ├── dist/           # ビルド出力
   ├── scripts/        # ビルドスクリプト
   │   └── build-windows.ps1  # Windows向けビルド
   ├── package.json
   └── tsconfig.json
   ```

### 11.4 段階的な実装アプローチ

**フェーズ1: 基盤構築（1週間）**
- Electronアプリの起動
- TypeScriptのビルド設定
- IPCの基本的な通信
- SQLite3の接続確認

**フェーズ2: コア機能（2-3週間）**
- データベーススキーマの実装
- 基本的なCRUD操作
- シンプルなUI（最小限）

**フェーズ3: 機能拡張（1ヶ月）**
- なんでもボックス
- ノード管理
- 基本的な検索

**重要**：各フェーズで必ず動作するものを作り、段階的に機能を追加する。一度に全てを実装しようとしない。

### 11.5 トラブルシューティングガイド

**よくある問題と解決策**：

1. **「Cannot find module」エラー**
   - 原因：パスの解決問題
   - 解決：相対パスではなく、__dirnameを使用

2. **「file is not a database」エラー**
   - 原因：SQLite3ファイルの破損
   - 解決：ファイルの存在チェックと再作成ロジック

3. **IPCハンドラーが呼ばれない**
   - 原因：preloadスクリプトの設定ミス
   - 解決：contextBridgeの適切な設定

### 11.6 避けるべき事項
- DuckDBのようなElectronとの互換性が不明なライブラリの採用
- 過度に複雑なアーキテクチャ
- ネイティブモジュールへの過度な依存

### 10.2 推奨事項
- シンプルで実績のあるライブラリの選択（SQLite3など）
- 段階的な機能追加
- 頻繁なテストとフィードバック
- コードの可読性と保守性を重視

### 10.3 技術選定の基準
1. Electronとの互換性が確認されている
2. 日本語処理に対応している
3. ドキュメントが充実している
4. アクティブにメンテナンスされている
5. ライセンスが商用利用可能

## 11. 実装状況と詳細要件（開発日誌とコードからの抽出）

### 11.1 実装済み機能の詳細

#### データベース基盤
- **SQLite3への完全移行** (2025-07-03完了)
  - ConnectionManagerによるシングルトン接続管理
  - 同期APIの採用（better-sqlite3）
  - トランザクション処理の実装
  - エラーハンドリングの統一化
  - データベース破損時の自動再作成機能

#### ナレッジ管理システム
- **なんでもボックスの完全実装**
  - テキスト、URL、画像の多様な入力対応
  - AIによるインスピレーション抽出（5つ生成）
  - 自動的なベクトル埋め込み生成
  - 重複URLチェック機能
  - メタデータの自動付与（作成日時、ソース情報等）

- **Webクローラー機能**
  - 最大5段階の深さ制限
  - 1秒以上のレート制限
  - AIによるメインコンテンツ抽出
  - インクリメンタル更新対応
  - リンク構造の保持

- **セレンディピティ検索の実装**
  - VectorSearchServiceによるカスタム実装
  - コサイン類似度計算
  - ノイズ注入（ガウシアンノイズ、次元選択的摂動）
  - ハイブリッド検索（BM25 + ベクトル類似度）

#### AI統合機能
- **マルチエージェントシステム**
  - 4種類のエージェント（作家、編集、校閲、副編集長）
  - OpenAI Assistants APIによるThread管理
  - エージェント間の非同期対話
  - メッセージ要約機能（100トークン以内）
  - トークンカウント管理（gpt-tokenizer使用）

- **ローカル埋め込み生成**
  - @xenova/transformersによる実装
  - multilingual-e5-baseモデル使用
  - 1024次元のベクトル生成
  - バッチ処理対応

#### プロジェクト管理機能
- **24時間自律モード**
  - プロジェクト単位での有効/無効設定
  - 活動インターバル設定（デフォルト30分）
  - 品質スコアしきい値設定（デフォルト0.7）
  - 最大トークン使用量制限
  - 活動ログの詳細記録

- **バックアップシステム**
  - 自動バックアップ設定（間隔、保持数）
  - 圧縮保存（gzip）
  - メタデータ付きバックアップ
  - リストア機能

### 11.2 データベーススキーマ詳細

#### コアテーブル構造
```sql
-- プロジェクト管理
projects (id, name, description, created_at, updated_at, metadata)

-- ナレッジ管理
knowledge (id, project_id, type, title, content, embeddings, metadata, created_at, updated_at)
knowledge_links (id, source_id, target_id, link_type, strength, metadata, created_at)

-- キャラクター管理
characters (id, project_id, name, description, personality, appearance, background, relationships, metadata, created_at, updated_at)

-- プロット管理
plots (id, project_id, parent_plot_id, version, title, structure, summary, metadata, created_at, updated_at)

-- 章管理
chapters (id, project_id, plot_id, chapter_number, title, content, summary, word_count, character_count, status, metadata, created_at, updated_at)

-- エージェントシステム
agent_discussions (id, project_id, plot_id, chapter_id, purpose, participants, status, summary, metadata, created_at, updated_at)
agent_messages (id, discussion_id, agent_type, message_content, message_type, metadata, created_at)
```

#### 運用系テーブル
```sql
-- API使用状況
api_usage_logs (id, api_type, endpoint, model, prompt_tokens, completion_tokens, total_tokens, estimated_cost, metadata, created_at)

-- 自律モード
autonomous_config (project_id, enabled, check_interval_minutes, quality_threshold, max_tokens_per_day, metadata, updated_at)
autonomous_activities (id, project_id, activity_type, description, quality_score, tokens_used, result_data, created_at)

-- バックアップ
backup_history (id, backup_type, file_path, file_size, compression, metadata, created_at)

-- バージョン管理
version_history (id, entity_type, entity_id, version_number, content, checksum, metadata, created_at)

-- アプリケーション設定
app_settings (key, value, updated_at)
```

### 11.3 パフォーマンス最適化の実装

- **インデックス設計**
  - プライマリキー、外部キー自動インデックス
  - 頻繁に検索されるカラムへのインデックス
  - 複合インデックスの適切な配置

- **ビューの活用**
  - active_projects_view: アクティブなプロジェクト一覧
  - api_usage_summary_view: API使用状況サマリー
  - recent_activities_view: 最近の活動一覧

- **接続管理の最適化**
  - シングルトンパターンによる接続再利用
  - プリペアドステートメントの活用
  - トランザクションの適切な利用

### 11.4 エラーハンドリングとログ

- **統一されたエラーハンドリング**
  - wrapIPCHandlerによる一元管理
  - カスタムエラークラス（DatabaseError、ValidationError、AIServiceError等）
  - エラーコードとメッセージの標準化

- **ログシステム**
  - IPCハンドラーレベルでの自動ログ
  - エラートレースの詳細記録
  - パフォーマンスメトリクスの記録

### 11.5 開発プロセスの要件

- **コード品質管理**
  - ESLintによる静的解析
  - Prettierによるコードフォーマット
  - TypeScriptの厳格な型チェック

- **テスト戦略**
  - リポジトリ層の統合テスト実装済み
  - モックを使用した単体テスト
  - E2Eテストの準備（Playwright設定済み）

- **CI/CDパイプライン**
  - GitHub Actionsによる自動化
  - マルチプラットフォームビルド
  - 自動テスト実行

## 改訂履歴
- 2025-07-03: 初版作成（会話履歴からの要求抽出）
- 2025-07-03: 第2版作成（開発日誌とコードからの詳細要件追加）